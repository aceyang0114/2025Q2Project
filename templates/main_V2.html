<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="{{ url_for('static', filename='Image/favicon.ico') }}" type="image/x-icon">
    <title>å·¡æª¢ç³»çµ±ï¼ˆç·šä¸Šæ¨¡å¼ï¼‰</title>
    <script src="https://cdn.jsdelivr.net/npm/openvino@latest/dist/openvino-web.js"></script>
</head>
<body>
<h2>è¼¸å…¥å·¡æª¢è³‡è¨Š</h2>
<label>å·¡æª¢ç³»çµ±<input type="text" id="System" /></label><br>
<label>å·¡æª¢é»ç·¨è™Ÿ<input type="text" id="Number" /></label><br>
<button onclick="saveData()">â• å„²å­˜åˆ°æœ¬åœ°</button>
<button onclick="uploadData()">ğŸ“¤ ä¸Šå‚³æ‰€æœ‰è³‡æ–™</button><br><br>

<video id="video" width="300" autoplay muted playsinline></video><br>
<button onclick="startCamera()">ğŸ“· å•Ÿç”¨é¡é ­</button>
<button onclick="captureAndRecognize()">ğŸ“¸ æ‹ç…§ä¸¦è¾¨è­˜</button><br>
<canvas id="canvas" style="display:none;"></canvas>
<p id="status">ğŸ“¦ æœ¬åœ°æš«å­˜ç­†æ•¸ï¼š0</p>
<p id="ocr-status"></p>
<button onclick="initOV()">è¼‰å…¥æ¨¡å‹</button>


<script type="module">
    import * as ov from 'https://storage.openvinotoolkit.org/repositories/openvino/web/latest/ov.js';
    // IndexedDB æœ¬åœ°å­˜å„²
    let db;
    const request = indexedDB.open("BusinessCardDB", 1);
    request.onerror = e => console.error("âŒ è³‡æ–™åº«é–‹å•Ÿå¤±æ•—", e);
    request.onsuccess = e => { db = e.target.result; updateCount(); };
    request.onupgradeneeded = e => {
        db = e.target.result;
        db.createObjectStore("cards", { keyPath: "id", autoIncrement: true });
    };

    function saveData(){
        const tx = db.transaction("cards", "readwrite");
        const store = tx.objectStore("cards");
        const record = {
            system: document.getElementById("System").value,
            number: document.getElementById("Number").value,
            timestamp: new Date().toISOString()
        };
        store.add(record);
        tx.oncomplete = updateCount;
    }

    function updateCount(){
        const tx = db.transaction("cards", "readonly");
        const store = tx.objectStore("cards");
        const request = store.getAll();
        request.onsuccess = () => {
            document.getElementById("status").textContent = `ğŸ“¦ æœ¬åœ°æš«å­˜ç­†æ•¸ï¼š${request.result.length}`;
        };
    }

    function uploadData(){
        const tx = db.transaction("cards", "readonly");
        const store = tx.objectStore("cards");
        const request = store.getAll();
        request.onsuccess = async () => {
            const data = request.result;
            try {
                const res = await fetch("/upload", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(data)
                });
                if (res.ok) {
                    const txDel = db.transaction("cards", "readwrite");
                    const storeDel = txDel.objectStore("cards");
                    data.forEach(item => storeDel.delete(item.id));
                    txDel.oncomplete = updateCount;
                    alert("âœ… ä¸Šå‚³æˆåŠŸä¸¦æ¸…é™¤æœ¬åœ°è³‡æ–™");
                } else {
                    alert("âŒ ä¸Šå‚³å¤±æ•—");
                }
            } catch (err) {
                alert("âŒ éŒ¯èª¤ï¼š" + err.message);
            }
        };
    }

    // é¡é ­å•Ÿç”¨
    let stream;
    async function startCamera(){
        try {
            stream = await navigator.mediaDevices.getUserMedia({ video: true });
            document.getElementById("video").srcObject = stream;
        } catch (err) {
            alert("ç„¡æ³•å•Ÿç”¨é¡é ­ï¼š" + err.message);
        }
    }

    // OpenVINO åˆå§‹åŒ–
    let ovCore, ovModel, ovCompiled;
    async function initOV(){
        try {
            ovCore = new ov.Core();
            ovModel = await ovCore.read_model("/static/models/cht_model.xml", "/static/models/cht_model.bin");
            ovCompiled = ovCore.compile_model(ovModel, "CPU");
            console.log("âœ… OpenVINO æ¨¡å‹è¼‰å…¥æˆåŠŸ");
        } catch (err) {
            console.error("âŒ OpenVINO è¼‰å…¥å¤±æ•—ï¼š", err);
            alert("æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ˜¯å¦å­˜åœ¨æˆ–è·¯å¾‘æ­£ç¢º");
        }
    }

    window.initOV = initOV;

    // æ‹ç…§è¾¨è­˜
    async function captureAndRecognize(){
        if (!ovCompiled) {
            await initOV();
            if (!ovCompiled) return;
        }

        const canvas = document.getElementById("canvas");
        const video = document.getElementById("video");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        canvas.getContext("2d").drawImage(video, 0, 0);

        document.getElementById("ocr-status").textContent = "ğŸ” æ­£åœ¨æœ¬åœ°è¾¨è­˜ï¼ˆOpenVINOï¼‰...";
        try {
            const inputTensor = imageToTensorOV(canvas);
            const inferReq = ovCompiled.create_infer_request();
            inferReq.set_tensor(ovCompiled.input(), inputTensor);
            const out = inferReq.infer();
            const data = out[ovCompiled.output().get_any_name()].data;
            const text = decodeTextOV(Array.from(data));
            document.getElementById("ocr-status").textContent = "âœ… å·²è¾¨è­˜å®Œæˆ";

            const parts = text.split("\n");
            document.getElementById("System").value = parts[0] || "";
            document.getElementById("Number").value = parts[1] || "";
            if (!parts[0] || !parts[1]) {
                alert("âš ï¸ æœ‰æ¬„ä½æœªè¾¨è­˜æˆåŠŸï¼Œè«‹ç¢ºèªæ‹æ”å“è³ªæˆ–æ‰‹å‹•èª¿æ•´");
            }
        } catch (err) {
            console.error("è¾¨è­˜éŒ¯èª¤ï¼š", err);
            document.getElementById("ocr-status").textContent = "âŒ è¾¨è­˜å¤±æ•—ï¼š" + err.message;
        }
    }

    function imageToTensorOV(canvas){
        const ctx = canvas.getContext("2d");
        const { data, width, height } = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const float32 = new Float32Array(width * height * 3);
        for (let i = 0; i < width * height; i++) {
            float32[i * 3] = data[i * 4] / 255;
            float32[i * 3 + 1] = data[i * 4 + 1] / 255;
            float32[i * 3 + 2] = data[i * 4 + 2] / 255;
        }
        return new ov.Tensor(new ov.Type.f32(), [1, 3, height, width], float32);
    }

    function decodeTextOV(logits) {
        const dict = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzä¸€ä¹™äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒè¬å·¡æª¢ç³»çµ±é»ä½ç·¨è™Ÿ ";
        const num_classes = dict.length + 1;  // åŠ ä¸Š blank class
        const timesteps = logits.length / num_classes;

        let result = "", prev = -1;

        for (let t = 0; t < timesteps; t++) {
            const start = t * num_classes;
            const end = start + num_classes;
            const timestep_logits = logits.slice(start, end);
            const max_idx = timestep_logits.indexOf(Math.max(...timestep_logits));

            if (max_idx !== 0 && max_idx !== prev) {  // è·³é blank å’Œé‡è¤‡
                result += dict[max_idx - 1];
            }
            prev = max_idx;
        }
        return result;
    }
</script>
</body>
</html>
