<script src="https://cdn.jsdelivr.net/npm/openvino@latest/dist/openvino-web.js"></script>
<script type="module">
    import * as ov from 'https://storage.openvinotoolkit.org/repositories/openvino/web/latest/ov.js';
    let ovCore, ovModel, ovCompiled;

    async function initOV() {
        ovCore = new ov.Core();
        ovModel = await ovCore.read_model("/static/models/cht_model.xml", "/static/models/cht_model.bin");
        ovCompiled = ovCore.compile_model(ovModel, "CPU");
    }

    async function captureAndRecognize() {
        console.log("â¡ click æ•æ‰é–‹å§‹");
        if (!ovCompiled) {
            console.log("â¡ å°šæœª initï¼Œé–‹å§‹ initOV()");
            await initOV();
        }
        if (!ovCompiled) {
            console.error("âŒ initOV å¤±æ•—ï¼Œç„¡æ³•ç¹¼çºŒè¾¨è­˜");
            return;
        }

        const canvas = document.createElement("canvas");
        const video = document.getElementById("video");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(video, 0, 0);
        console.log("ğŸ¥ å·² capture ç•«é¢ï¼Œå°ºå¯¸", canvas.width, canvas.height);

        document.getElementById("ocr-status").textContent = "ğŸ” è¾¨è­˜ä¸­...";
        const inputTensor = imageToTensorOV(canvas);
        console.log("inputTensor shape:", inputTensor.dims);

        const inferReq = ovCompiled.create_infer_request();
        inferReq.set_tensor(ovCompiled.input(), inputTensor);
        const out = inferReq.infer();
        const outName = ovCompiled.output().get_any_name();
        const data = out[outName].data;
        console.log("output data len:", data.length, data.slice(0,10));

        const text = decodeTextOV(Array.from(data));
        console.log("è¾¨è­˜çµæœæ–‡å­—:", text);

        document.getElementById("ocr-status").textContent = "âœ… å·²è¾¨è­˜å®Œæˆ";
        const parts = text.split("\n");
        document.getElementById("System").value = parts[0] || "";
        document.getElementById("Number").value = parts[1] || "";
    }

    function imageToTensorOV(canvas) {
        const ctx = canvas.getContext("2d");
        const {data, width, height} = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const float32 = new Float32Array(width * height * 3);
        for (let i = 0; i < width * height; i++) {
            float32[i*3] = data[i*4]/255;
            float32[i*3+1] = data[i*4+1]/255;
            float32[i*3+2] = data[i*4+2]/255;
        }
        return new ov.Tensor(new ov.Type.f32(), [1, 3, height, width], float32);
    }

    function decodeTextOV(logits) {
        const dict = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzä¸€ä¹™äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒè¬å·¡æª¢ç³»çµ±é»ä½ç·¨è™Ÿ ";
        const num_classes = dict.length + 1;  // åŠ ä¸Š blank class
        const timesteps = logits.length / num_classes;

        let result = "", prev = -1;

        for (let t = 0; t < timesteps; t++) {
            const start = t * num_classes;
            const end = start + num_classes;
            const timestep_logits = logits.slice(start, end);
            const max_idx = timestep_logits.indexOf(Math.max(...timestep_logits));

            if (max_idx !== 0 && max_idx !== prev) {  // è·³é blank å’Œé‡è¤‡
                result += dict[max_idx - 1];
            }
            prev = max_idx;
        }
        return result;
    }
    async function initOV(){
        try {
            ovCore = new ov.Core();
            ovModel = await ovCore.read_model("/static/models/cht_model.xml", "/static/models/cht_model.bin");
            ovCompiled = ovCore.compile_model(ovModel, "CPU");
            console.log("âœ… OpenVINO æ¨¡å‹è¼‰å…¥æˆåŠŸ");
        } catch (err) {
            console.error("âŒ OpenVINO è¼‰å…¥å¤±æ•—ï¼š", err);
            alert("æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ˜¯å¦å­˜åœ¨æˆ–è·¯å¾‘æ­£ç¢º");
        }
    }
</script>
